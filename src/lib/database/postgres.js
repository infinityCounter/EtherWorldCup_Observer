const _ = require('lodash');
const Sequelize = require('sequelize');

const logger = require('../logging/logger.js');

class PgClient {

    constructor(config) {
        this.config          = config;
        // Don't persist data in the client
        // Just use these to temporarily cache data until a save then clear
        // move what's important into cache for quick access
        this.teams              = [];
        this.matches            = [];
        this.unpersistedBets    = [];
        this.cancelledBets      = [];
        this.claimedBets        = [];
        this.intervalId         = null;
    }

    async setup(forceMigrate = false) {
        await this.init(forceMigrate);
        logger.log('postgres', 'info', 'Connected to postgres successfully!');
    }

    async init(force = false) {
        this.db = new Sequelize(this.config.ConnectionString(),
            {
                pool: {
                    max: this.config.MaxPool,
                    min: 0,
                    acquire: 30000,
                    idle: 10000
                },
                define: {
                    timestamps: false
                },
                logging: false
            }
        );
        await this.db.authenticate();

        const has_actual_primary_key = function(modelInstance) {
            const attrs = Object.keys(modelInstance.attributes)
            const pk_fields = attrs.filter(x => {
              return modelInstance.attributes[x].primaryKey && !modelInstance.attributes[x]._autoGenerated
            })
            return pk_fields.length>0
        };

        const bulk_upsert = function(rows, obj) {
            let model = this;
            return Promise.all(rows.map( (row) => {
                if(has_actual_primary_key(model)) {
                    return model.upsert(row, obj);
                } else {
                    return model.findOrCreate({
                    where: row,
                    defaults: row
                    }, obj);
                }
            }));
        }

        this.models = {};
        this.models.Team = this.db.define('teams', {
            Id: {
                type: Sequelize.INTEGER,
                allowNull: false,
                field: 'id',
                primaryKey: true,
            },
            Name: {
                type: Sequelize.STRING,
                allowNull: false,
                field: 'name',
                unique: true,
            }
        });
        this.models.Match = this.db.define('matches', {
            Id: {
                type: Sequelize.INTEGER,
                primaryKey: true,
                field: 'id'
            },
            FixtureId: {
                type: Sequelize.INTEGER,
                allowNull: false,
                field: 'fixture_id'
            },
            SecondaryFixtureId: {
                type: Sequelize.INTEGER,
                allowNull: false,
                field: 'secondary_fixture_id'
            },
            Inverted: {
                type: Sequelize.BOOLEAN,
                allowNull: false,
                defaultValue: false,
                field: 'inverted'
            },
            Name: {
                type: Sequelize.STRING,
                allowNull: false,
                field: 'name'
            },
            HomeTeam: {
                type: Sequelize.INTEGER,
                references: {
                    model: 'teams',
                    key: 'id'
                },
                field: 'team_a',
                allowNull: false
            },
            AwayTeam: {
                type: Sequelize.INTEGER,
                references: {
                    model: 'teams',
                    key: 'id'
                },
                field: 'team_b',
                allowNull: false
            },
            StartTime: {
                type: Sequelize.INTEGER, 
                field: 'start_time',
                allowNull: false
            },
            CloseTime: {
                type: Sequelize.INTEGER, 
                field: 'betting_close_time',
                allowNull: false
            },
            Winner: {
                type: Sequelize.INTEGER,
                field: 'winner'
            },
            Locked: {
                type: Sequelize.BOOLEAN,
                defaultValue: false,
                field: 'locked'
            },
            Cancelled: {
                type: Sequelize.BOOLEAN,
                defaultValue: false,
                field: 'cancelled'
            }
        });
        this.models.Bet = this.db.define('bets', {
            Id: {
                type: Sequelize.INTEGER,
                unique: 'composite',
                field: 'id',
                primaryKey: false
            },
            Address: {
                type: Sequelize.STRING(42),
                allowNull: false,
                field: 'better'
            },
            Amount: {
                type: Sequelize.DECIMAL(18,8),
                defaultValue: 0,
                allowNull: false,
                field: 'amount'
            },
            Decision: {
                type: Sequelize.ENUM,
                values: ['1', '2', '3'],
                allowNull: false,
                field: 'decision'
            },
            Match: {
                type: Sequelize.INTEGER,
                field: 'matchId',
                references: {
                    model: 'matches',
                    key: 'id'
                },
                allowNull: false,
                unique: 'composite',
            },
            Cancelled: {
                type: Sequelize.BOOLEAN,
                defaultValue: false,
                field: 'cancelled'
            },
            Claimed: {
                type: Sequelize.BOOLEAN,
                defaultValue: false,
                field: 'claimed'
            }
        }, {
            indexes: [
                {
                    name: 'bet_match_better_index',
                    fields: ['matchId', 'better'],
                    where: {
                      cancelled: 'false'
                    }
                },
            ]
        });
        this.models.Match.hasMany(this.models.Bet);
        this.models.Bet.belongsTo(this.models.Match)
        await this.db.sync({force: force});
        const keys = Object.keys(this.models);
        keys.map((key) => {
            this.models[key].bulkUpsert = bulk_upsert;
        });
    }

    async saveMatches() {
        logger.log('postgres', 'info', 'Attempting to save matches');
        await this.models.Match.sequelize.transaction((t) =>{
            return this.models.Match.bulkUpsert(this.matches, {transaction: t});
        });
        this.matches = [];
        logger.log('postgres', 'info', 'Saved matches');
    }

    async saveTeams() {
        logger.log('postgres', 'info', 'Attempting to save teams');
        await this.models.Team.sequelize.transaction((t) => {
            return this.models.Team.bulkUpsert(this.teams, {transaction: t});
        });
        this.teams = [];
        logger.log('postgres', 'info', 'Saved teams');
    }

    buildBulkChangeQuery(bets, action) {
        let params = [];
        let counter = 1;
        bets.map((bet, idx) => {
            params.push(`("matchId"=$${counter++} AND id=$${counter++})`);
        })
        return `UPDATE bets SET ${action} = true WHERE (${params.join(" OR ")});`;
    }

    async saveBets() {
        logger.log('postgres', 'info', 'Attempting to save bets');
        await this.models.Bet.sequelize.transaction(t => {
            let promiseArr = [];
            // Create new bets
            if (this.unpersistedBets.length > 0) {
                promiseArr.push(
                    this.models.Bet.bulkCreate(
                        this.unpersistedBets, 
                        {transaction: t, returning: true}
                    )
                );
            }
            // Cancel any bets that should be cancelled
            if (this.cancelledBets.length > 0) {
                promiseArr.push(
                    this.db.query(
                        this.buildBulkChangeQuery(this.cancelledBets, "cancelled"), { 
                            bind: [].concat(...this.cancelledBets), 
                            type: Sequelize.QueryTypes.UPDATE,
                            transaction: t
                        }
                    )
                
                );
            }

            if (this.claimedBets.length > 0) {
                promiseArr.push(
                    this.db.query(
                        this.buildBulkChangeQuery(this.claimedBets, "claimed"), { 
                            bind: [].concat(...this.claimedBets), 
                            type: Sequelize.QueryTypes.UPDATE,
                            transaction: t
                        }
                    )
                
                );
            }
            return Promise.all(promiseArr);
        });
        this.unpersistedBets = [];
        this.cancelledBets = [];
        logger.log('postgres', 'info', 'Saved bets');
    }

    async save() {
        await this.saveTeams();
        await this.saveMatches();
        await this.saveBets();
    }

    die() {
        return this.db.close();
    }
}

module.exports.PgClient = PgClient;
